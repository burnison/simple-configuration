package ca.burnison.configuration;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.Objects;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import javax.annotation.Nonnull;

public abstract class Property<T, P extends Property<T, P>> {
    private final Constructor<? extends Property<T, P>> ctor;
    private final String name;
    private final Lookup<T> lookup;

    protected Property(final String name, final Lookup<T> lookup) {
        this.ctor = findConstructor();
        this.name = name;
        this.lookup = lookup;
    }

    Lookup<T> getLookup() {
        return this.lookup;
    }

    /**
     * Identifies if the property is currently present in any source. For
     * dynamic sources, a return of this method may not agree with those of a
     * call to {@link #get()}, since the lookup is performed twice. In those
     * cases, prefer using {@link #orElse(Object)}, which will perform an atomic
     * operation.
     *
     * @return False only if the property does not exist in any source. A return
     *      of true does not gaurantee a non-null value.
     */
    public final boolean isPresent() {
        return this.lookup.lookup().isPresent();
    }

    /**
     * Get the current value of this property. If the current property is not
     * present in any source, a null value may be returned. If consistency is
     * extremely critical, prefer using {@link #orElse(Object)}, which will
     * perform an atomic operation on the source.
     *
     * @return The value, which may legitimately be <code>null</code> either
     *      because the actual value is <code>null</code> or because the
     *      property is not present in any source.
     */
    public final T get() {
        return this.lookup.lookup().get();
    }

    /**
     * Get the current value of this property and returns the value after
     * applying the specified function. If the current property is not present
     * in any source, a null value may be returned.
     *
     * @param <O> The output type.
     * @param function The function to apply that may be invoked with a
     *      <code>null</code> argument.
     * @return The value, which may legitimately be <code>null</code> either
     *      because the actual value is <code>null</code> or because the
     *      property is not present in any source.
     * @throws NullPointerException If the function is null.
     */
    public final <O> O get(@Nonnull final Function<T, O> function) {
        return this.lookup.lookup().map(function).get();
    }

    /**
     * Get the current value of this property, or, if the current property is
     * not present in any source, return the specified value. The retured value
     * may be null if an underlying source has it set to null.
     *
     * @param defaultIfAbsent The non-null default value to use if this property
     *      is not currently in any sources.
     * @return The current value (which may be null) or the specified default.
     * @throws NullPointerException If the default is null.
     */
    public final T orElse(@Nonnull final T defaultIfAbsent) {
        return this.lookup.lookup().orElse(defaultIfAbsent);
    }

    /**
     * Get the current value of this property or, if the current property is
     * not present in a source, use the specified supplier to generate a default
     * value. The result may be null if an underlying source has set a null
     * value for this property.
     *
     * @param supplier The supplying function called when this property is not
     *      set in any sourc.
     * @return The current value (which may be null), or, if not present in any
     *      source, the value generated by the supplier.
     * @throws NullPointerException If supplier is null.
     */
    public final T orElseGet(@Nonnull final Supplier<? extends T> supplier) {
        return this.lookup.lookup().orElseGet(
                Objects.requireNonNull(supplier, "A non-null supplier must be provided."));
    }

    /**
     * Creates a snapshot of the current value that will be used for all
     * further access. Once frozen, a property cannot be unfrozen, however,
     * additional transformations may be used (for whatever odd reasons).
     *
     * @return A frozen copy of this property.
     */
    public final P frozen() {
        return this.replace(new StaticLookup<>(this.lookup));
    }

    /**
     * Adds a cache to this property that short-circuits other other types of
     * transformers or validators. When the underlying property is changed,
     * the cache is invalidated and the result is recomputed.
     *
     * @return A new property with the map applied.
     */
    // TODO: Make this public once fully implemented.
    public final P cached() {
        return this.replace(new CachingLookup<>(this.lookup));
    }

    /**
     * Adds a transformation layer on this property that will transform null
     * values. This function is of most use when combined with a map. A property
     * that is missing will not be coalesced; for such a use case, you should
     * instead use {@link #required(Object)}.
     *
     * @param ifNull The value to use if this property is null.
     * @return A new property with the map applied.
     * @throws NullPointerException If ifNull is null.
     */
    public final P coalesced(@Nonnull final T ifNull) {
        return this.mapped(v -> v == null ? Objects.requireNonNull(ifNull, "A non-null default must be provided.") : v);
    }

    /**
     * Apply a transformer to this property that is applied on each access.
     * Additional transformations may be applied at access time using the
     * {@link #get(Function)} method.
     *
     * @param function The function to be applied during access.
     * @return A new property with the map applied
     * @throws NullPointerException If the function parameter is null.
     */
    public final P mapped(@Nonnull final Function<T, T> function) {
        final TransformingLookup<T, T> lookup = new TransformingLookup<>(
            this.lookup,
            Objects.requireNonNull(function, "A function must be provided.")
        );
        return this.replace(lookup);
    }

    /**
     * Apply a function to this property that is applied on each access and
     * return an unwrapped property type. While this method has great utility,
     * you are encouraged to use the wrapped types whenever possible.
     *
     * @param <O> The desired output data type.
     * @param function The function to be applied during access.
     * @return A new, unwrapped property with the function applied
     * @throws NullPointerException If the function parameter is null.
     */
    public final <O> AnyTypeProperty<O> unwrapped(@Nonnull final Function<T, O> function) {
        final TransformingLookup<T, O> lookup = new TransformingLookup<>(
            this.lookup,
            Objects.requireNonNull(function, "A function must be provided.")
        );
        return new AnyTypeProperty<O>(this.name, lookup);
    }

    /**
     * Ensure that this property matches the specified predicate. If the
     * property does not match the specified validator at the time of access,
     * an {@link PropertyInvalidException} is thrown.
     *
     * @param predicate The predicate to be applied during access.
     * @return A new property with the validation applied.
     * @throws NullPointerException If the predicate is null.
     */
    public final P validated(@Nonnull final Predicate<T> predicate) {
        final ValidatingLookup<T> lookup = new ValidatingLookup<>(
            this.lookup,
            Objects.requireNonNull(predicate)
        );
        return this.replace(lookup);
    }

    /**
     * Ensure that this property is present in an existing source. If the
     * property does not exist in any underlying source at the time of access,
     * an {@link PropertyMissingException} is thrown.
     *
     * @return A new property with the validation applied.
     */
    public final P required() {
        return this.replace(new RequiringLookup<>(this.lookup));
    }

    /**
     * Ensure that this property is present in an existing source, but, instead
     * of failing at runtime like {@link #required()}, this method will
     * substitute a non-null default value.
     *
     * @param defaultIfAbsent The non-null default value to apply if this
     *      property is not present in any existing sources.
     * @return A new property with the applied default.
     * @throws NullPointerException If defaultIfAbsent is null.
     */
    public final P required(@Nonnull final T defaultIfAbsent) {
        final DefaultingLookup<T> lookup = new DefaultingLookup<>(
            this.lookup,
            Objects.requireNonNull(defaultIfAbsent, "A non-null default is required.")
        );
        return this.replace(lookup);
    }

    /**
     * For the current instance, create a new instance with the specified
     * lookup. This method is a convenience method to reduce the amount of
     * boilerplate code in subclasses. Further, because properties are intended
     * to be created and held at creation time, the performance impact of
     * reflection should be considered insignificant. Another way of solving
     * this would be introducing an abstract method to be extended into each
     * subclass.
     *
     * @param lookup
     * @throws IllegalStateException If this property cannot be replaced.
     */
    @SuppressWarnings("unchecked")
    private P replace(final Lookup<T> lookup) {
        try {
            return (P) this.ctor.newInstance(name, lookup);
        } catch (final InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Unable to replace " + this.name + ". Is this a custom subclass?");
        }
    }

    @SuppressWarnings("unchecked")
    private Constructor<? extends Property<T, P>> findConstructor() {
        try {
            final Class<?>[] args = { String.class, Lookup.class };
            return (Constructor<? extends Property<T, P>>) getClass().getDeclaredConstructor(args);
        } catch (final NoSuchMethodException ex) {
            throw new IllegalStateException("Property type " + getClass().getName() + " cannot be replaced."
                    + " Is this a cutsom subclass? If so, do you have the necessary constructor?", ex);
        }
    }
}
